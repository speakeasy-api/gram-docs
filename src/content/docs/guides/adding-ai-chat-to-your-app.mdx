---
title: "Add AI Chat to Your CRUD App"
description: "Learn how to add a chat interface to your existing CRUD application in four practical steps while keeping your current backend and business logic completely unchanged."
sidebar:
  order: 1
---

You built a CRUD app. Your users create tasks, update records, and filter through data. But they spend too much time navigating your UI for simple requests. What if instead of clicking through filters and forms, they could just ask for what they need?

"Show me all tasks assigned to Sarah that are due this week." "Move the client presentation task to done." "Create a task for the database migration due Friday."

This guide shows you how to add a chat interface to your existing CRUD application in four practical steps. Your users get natural language interaction, while you keep your current backend, security model, and business logic completely unchanged.

<video width="600" controls>
  <source src="/videos/taskboard-show-tasks.mp4" type="video/mp4" />
    Your browser does not support the video tag.
</video>

We'll use the [TaskBoard example app](https://github.com/ritza-co/TaskBoard) as a demo. The main branch shows our starting point (CRUD app without chat), and the [completed-ai-chat branch](https://github.com/ritza-co/TaskBoard/tree/completed-ai-chat) shows the final result.

![Github branches](/img/blog/adding-ai-chat-to-your-app-guide/github-branches.png)


:::note[Live Demo]
Try a [live demo of the TaskBoard app with a chat assistant here](https://taskboard.abduldavids.co.za).
:::

### Adding an AI assistant to a task management app

Here's how we'll transform a standard CRUD application into one with natural language capabilities.

We have a working task management app with a standard structure:

```
TaskBoard/
├── taskboard/                 # Your existing Next.js app
│   ├── src/
│   │   ├── app/api/           # Your CRUD API routes
│   │   │   ├── items/         # Task CRUD operations
│   │   │   ├── login/         # User authentication  
│   │   │   └── register/      # User registration
│   │   ├── components/        # React components
│   │   └── lib/               # Database & auth helpers
│   └── prisma/                # SQLite database
└── docker-compose.yml         # Container setup
```

Here's what the app looks like currently:

![The TaskBoard user interface](/img/blog/adding-ai-chat-to-your-app-guide/taskboard-interface.png)

Users interact with your app manually: clicking, typing and moving tasks. It works, but we want users to "feel the AGI" when interacting with their tasks.

### What we'll add

We'll add a small chat microservice and popup chat component to your existing app:

```
TaskBoard/
├── taskboard/                 # Your existing Next.js app (unchanged)
│   ├── src/
│   │   ├── app/api/           
│   │   │   ├── items/         # Same CRUD API
│   │   │   ├── chat/          # New: proxy to chat service
│   │   │   ├── login/         # Same auth
│   │   │   └── register/      # Same auth
│   │   ├── components/        
│   │   │   ├── KanbanBoard/   # Same task board
│   │   │   └── ChatComponent/ # New: floating chat popup
│   │   └── lib/               # Same database & auth
├── mcp-agent-service/         # New: small chat microservice
│   ├── main.py                # FastAPI + OpenAI Agents SDK
│   ├── requirements.txt       # 6 dependencies
│   └── Dockerfile             # Python container
└── docker-compose.yml         # Updated: runs both services
```

Here's what the app looks like with the chat component added:

![TaskBoard with chat functionality](/img/blog/adding-ai-chat-to-your-app-guide/taskboard-with-chat.png)

### How it works

For the chat service, we'll use [OpenAI's Agents SDK](https://openai.github.io/openai-agents-python/) to connect to your existing API. Here's the complete flow:

1. User types: "Show me overdue tasks"
2. Chat popup → Your Next.js API → Chat Service 
3. OpenAI Agents SDK calls your existing `/api/items` endpoint
4. Response flows back with results formatted as natural language
5. TaskBoard UI updates to show the filtered results

![Using the TaskBoard chat to ask the agent to delete a task](/img/blog/adding-ai-chat-to-your-app-guide/taskboard-delete-task.png)

Your existing app stays exactly the same. Same database, same authentication, same business logic. You're just adding a new component to what you already built.

### Architecture details

Here's the complete architecture we're building:

![Diagram of the MCP-powered chat integration architecture](/img/blog/adding-ai-chat-to-your-app-guide/architecture-diagram.png)

**Before (manual interaction only)**:
- User clicks "Add Task" button → TaskBoard UI → POST /api/items → Database
- User drags task to "Done" → TaskBoard UI → PATCH /api/items → Database

**After (+ natural language chat)**:

*Option 1: Traditional UI (unchanged)*
- User clicks "Add Task" → TaskBoard UI → POST /api/items → Database → UI updates

*Option 2: Using the chat popup*
1. User types "Create a task for the client meeting tomorrow"
2. Chat UI → /api/chat → FastAPI Chat Service → mcp-agent
3. Gram MCP Server → POST /api/items → Database
4. Success response → Chat Service → Chat UI shows "✅ Task created"
5. TaskBoard UI automatically refreshes and shows the new task

Most importantly, your existing `/api/items` endpoints don't change at all. We're just adding a way to call the same APIs your UI already uses, but using an LLM to interpret the user's intent.

We use [MCP (Model Context Protocol)](https://modelcontextprotocol.io/docs/getting-started/intro) to provide the OpenAI Agent with specific tools that can call your TaskBoard API. Gram converts your API endpoints into MCP tools that the agent can use.

## Prerequisites and setup

To follow this guide, you'll need:

- A [Gram account](https://getgram.ai) (free)
- An OpenAI API key from the [OpenAI dashboard](https://platform.openai.com/account/api-keys)
- Node.js and Docker for local development
- The [TaskBoard repository](https://github.com/ritza-co/TaskBoard) cloned locally

### Clone and run the starter app

First, we'll get the basic CRUD app running without any chat functionality. The TaskBoard app is already dockerized for easy setup:

```bash
git clone https://github.com/ritza-co/TaskBoard.git
cd TaskBoard

# Make sure you're on the main branch (CRUD only, no chat)
git checkout main

# Create environment file
cp .env.example .env

# Start with Docker (recommended for testing)
docker-compose up --build
```

Visit `http://localhost:3000`, register an account, and create a few tasks. Click the arrows to move them between columns. This is our starting point, a working task management app that users interact with manually.

## Step 1: Creating an MCP server

First we'll give the OpenAI Agent tools that can call your API endpoints. MCP (Model Context Protocol) provides a standard way to expose API operations as tools that AI agents can use.

We'll upload your API documentation to Gram, which converts your API endpoints into MCP tools and hosts them as an MCP server. The OpenAI Agents SDK can then connect to this server and use these tools to interact with your TaskBoard API.

### Generate your API documentation

Your TaskBoard app already includes OpenAPI generation. Let's create the documentation file:

```bash
# In the taskboard directory
npm run generate-docs
```

This creates `/public/swagger.json` with your complete API specification, including authentication requirements and data schemas. The existing JSDoc comments in your API routes (like `/api/items/route.ts`) provide the structure Gram needs to understand your endpoints.

:::tip
If you have your own CRUD app, you likely already have an OpenAPI spec. If not, tools like [next-swagger-doc](https://www.npmjs.com/package/next-swagger-doc) or [swagger-jsdoc](https://www.npmjs.com/package/swagger-jsdoc) can generate one from your existing code comments. To learn more about how to generate an OpenAPI spec in other frameworks, check out our [OpenAPI hub](https://www.speakeasy.com/openapi) over on the Speakeasy blog.
:::

### Upload to Gram and create your MCP server

Now we'll transform your API documentation into a hosted MCP server:

1. In the Gram dashboard, click **Toolsets** in the sidebar (under **CREATE**).
2. Click **+ ADD API**.
3. Upload your OpenAPI document (`public/swagger.json`).
4. Name your API (e.g., "TaskBoard"), toolset, and server slug (e.g., "taskboard-demo").

<video width="600" controls>
  <source src="/videos/taskboard-mcp-create.mp4" type="video/mp4" />
    Your browser does not support the video tag.
</video>

Gram parses your OpenAPI document and converts each endpoint into MCP tools. Find the MCP server in the **MCP** tab and set it to **Public** under the Visibility section.

![Gram MCP server](/img/blog/adding-ai-chat-to-your-app-guide/gram-public-mcp-server.png)

### Configure public access for development

For local development, expose your TaskBoard API so Gram can access it:

```bash
# Install ngrok if you haven't already
brew install ngrok  # or download from ngrok.com

# In a new terminal, expose your local API
ngrok http 3000
```

Copy the public URL (like `https://abc123.ngrok.io`) and add it to your Gram environment variables as `TASKBOARD_SERVER_URL`.

:::note[Production deployment]
We're using ngrok for local development testing. In production, you'd replace `TASKBOARD_SERVER_URL` with your actual API URL (like `https://api.taskboard.com`).
:::

![TaskBoard environment variables dialog](/img/blog/adding-ai-chat-to-your-app-guide/taskboard-env-var.png)

### Test your MCP server

Verify everything works in the Gram playground:

1. Go to **Playground** → Select your TaskBoard toolset
2. Try queries like "Show me all my tasks" or "Create a task called 'Review quarterly reports'"

![Testing the TaskBoard MCP tools in the Gram Playground](/img/blog/adding-ai-chat-to-your-app-guide/testing-mcp-taskboard.png)

:::note
You'll need to provide a `userId` in the Playground, or ask the agent to use login/register tools first. We'll automate this in the chat integration.
:::

Your API endpoints are now available as MCP tools! Copy the MCP server configuration from the **MCP Config** section—we'll need it for the chat service. 

## Step 2: Adding a chat popup to your frontend

Next we'll add a floating chat interface to your existing TaskBoard app. The chat window will appear as an overlay without interfering with your current functionality.

We're going to build a floating chat popup that looks like this:

![TaskBoard with chat functionality](/img/blog/adding-ai-chat-to-your-app-guide/taskboard-with-chat.png)

The chat component will be a floating button in the bottom-right corner that expands into a chat window when clicked. Let's build it step by step.

Create the chat component in your frontend:

```typescript
// taskboard/src/components/ChatComponent.tsx
import React, { useState, useRef, useEffect } from 'react';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
  isStreaming?: boolean;
  toolUsage?: any;
}

interface ChatComponentProps {
  userId: string;
  onChatClose?: () => void;
}

const ChatComponent: React.FC<ChatComponentProps> = ({ userId, onChatClose }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [sessionId, setSessionId] = useState<string | null>(null);

  const sendMessage = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      role: 'user',
      content: input.trim(),
      timestamp: new Date().toISOString(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      // We'll implement this API endpoint in the next step
      const response = await fetch(`/api/chat?userId=${encodeURIComponent(userId)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: userMessage.content,
          conversation_history: messages,
          session_id: sessionId,
        }),
      });

      if (!response.ok) throw new Error('Failed to send message');
      const data = await response.json();

      // Add AI response to chat
      const aiMessage: Message = {
        role: 'assistant',
        content: data.response,
        timestamp: new Date().toISOString(),
        toolUsage: data.tool_usage,
      };

      setMessages(prev => [...prev, aiMessage]);
      if (!sessionId) setSessionId(data.session_id);

      // Trigger refresh of TaskBoard if AI performed actions
      if (data.tool_usage?.has_tools && onChatClose) {
        setTimeout(onChatClose, 1000); // Refresh after AI action
      }
    } catch (error) {
      console.error('Error sending message:', error);
      // Add error message to chat
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="fixed bottom-8 right-8 z-50">
      {/* Chat button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="bg-blue-600 text-white p-4 rounded-full shadow-lg hover:bg-blue-700 transition-colors"
      >
        💬
      </button>

      {/* Chat window */}
      {isOpen && (
        <div className="absolute bottom-16 right-0 w-80 bg-white rounded-lg shadow-xl border border-gray-200">
          {/* Chat header */}
          <div className="flex justify-between items-center p-3 border-b border-gray-200">
            <h3 className="font-semibold text-gray-800">TaskBoard Assistant</h3>
            <button 
              onClick={() => setIsOpen(false)}
              className="text-gray-500 hover:text-gray-700"
            >
              ×
            </button>
          </div>

          {/* Messages area */}
          <div className="h-64 overflow-y-auto p-3 space-y-2">
            {messages.length === 0 && (
              <p className="text-gray-500 text-sm">Ask me to help with your tasks!</p>
            )}
            {messages.map((message, index) => (
              <div key={index} className={`${message.role === 'user' ? 'text-right' : 'text-left'}`}>
                <div className={`inline-block p-2 rounded-lg max-w-xs ${
                  message.role === 'user' 
                    ? 'bg-blue-600 text-white' 
                    : 'bg-gray-100 text-gray-800'
                }`}>
                  {message.content}
                </div>
              </div>
            ))}
            {isLoading && (
              <div className="text-left">
                <div className="inline-block p-2 rounded-lg bg-gray-100 text-gray-800">
                  Thinking...
                </div>
              </div>
            )}
          </div>

          {/* Input area */}
          <div className="p-3 border-t border-gray-200">
            <div className="flex space-x-2">
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                placeholder="Ask about your tasks..."
                className="flex-1 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <button
                onClick={sendMessage}
                disabled={isLoading || !input.trim()}
                className="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-blue-700 disabled:opacity-50"
              >
                Send
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ChatComponent;
```

### Adding the chat component to your dashboard

Now integrate the chat component into your main dashboard:

```typescript
// taskboard/src/app/dashboard/page.tsx
// Add this import at the top
import ChatComponent from '@/components/ChatComponent';

// Inside your dashboard component, add this at the end of the return statement:
{/* Floating Chat Component */}
{userId && <ChatComponent userId={userId} onChatClose={() => fetchItems(true)} />}
```

At this point, you have a chat interface that looks functional but doesn't connect to AI yet. The next step is adding the backend to make it work.

## Step 3: Creating the chat microservice

Now we'll create a small FastAPI service (about 100 lines of code) that handles the AI processing. This service uses OpenAI's Agents SDK.

**What this service does**:
1. Receives chat messages from your TaskBoard frontend
2. Creates an OpenAI Agent that has access to TaskBoard MCP tools (via Gram)
3. Agent decides which tools to use based on user intent
4. Returns natural language responses with the results

The OpenAI Agents SDK handles understanding user intent, choosing which MCP tools to call to achieve the user's intent, and generating responses based on the results of the MCP tools.

### Set up the chat service

Create the chat service directory:

```bash
# From the TaskBoard root directory
mkdir mcp-agent-service
cd mcp-agent-service
```

Create the requirements file:

```python 
# mcp-agent-service/requirements.txt
openai-agents
fastapi==0.116.1
uvicorn==0.35.0
python-dotenv==1.1.1
pydantic==2.11.7
httpx==0.28.1
requests==2.32.4
```

Create the main FastAPI service:

```python
# mcp-agent-service/main.py
import os
import uuid
import asyncio
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
# OpenAI Agents SDK - handles the AI agent logic
from agents import Agent, Runner, SQLiteSession
from agents.mcp import MCPServerStdio  # Connects to Gram MCP server

app = FastAPI(title="OpenAI Agents Chat Microservice", version="1.0.0")

# Validate required environment variables
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
TASKBOARD_SERVER_URL = os.getenv("TASKBOARD_SERVER_URL")

if not TASKBOARD_SERVER_URL:
    raise ValueError("TASKBOARD_SERVER_URL environment variable is required")

if not OPENAI_API_KEY:
    raise ValueError("OPENAI_API_KEY environment variable is required")

# Set OpenAI API key for the library
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY

# Add CORS middleware to allow requests from Next.js app
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ChatRequest(BaseModel):
    message: str
    conversation_history: List[Dict[str, Any]] = []
    session_id: Optional[str] = None

class ChatResponse(BaseModel):
    response: str
    session_id: str
    user_message_count: int
    tool_usage: Optional[Dict[str, Any]] = None

def extract_user_id_from_history(conversation_history: List[Dict[str, Any]]) -> Optional[str]:
    """Extract user ID from system message in conversation history."""
    for msg in conversation_history:
        if msg.get('role') == 'system' and msg.get('content'):
            content = msg['content']
            if 'User ID:' in content:
                return content.split('User ID:')[1].split('.')[0].strip()
    return None

async def create_mcp_server() -> MCPServerStdio:
    """Create MCP server connection to Gram.
    
    This connects to your Gram MCP server, which acts as a bridge
    between the OpenAI Agent and your TaskBoard API.
    """
    return MCPServerStdio(
        name="GramTaskboard",
        params={
            "command": "npx",  # Uses the mcp-remote package
            "args": [
                "mcp-remote",
                "https://app.getgram.ai/mcp/ritza-rzx-taskboard-demo",  # Replace with your Gram MCP server URL
                "--header",
                f"MCP-TASKBOARD-SERVER-URL:{TASKBOARD_SERVER_URL}",  # Tells Gram where to find your API
                "--timeout", "120000"
            ]
        },
        cache_tools_list=True,  # Cache for performance
        client_session_timeout_seconds=120.0,
        max_retry_attempts=2,
        retry_backoff_seconds_base=2.0
    )

async def create_agent_with_mcp(user_id: str, mcp_server: MCPServerStdio) -> Agent:
    """Create an OpenAI Agent that knows how to use your TaskBoard API.
    
    The Agent automatically discovers your API endpoints via the MCP server
    and learns how to call them based on user requests.
    """
    return Agent(
        name="TaskBoard Assistant",
        instructions=f"""You are a helpful assistant that can manage tasks in a TaskBoard application.
        You can list, create, update, delete, and search for tasks using the available MCP tools.
        
        When interacting with tasks:
        - Always use the provided MCP tools to perform TaskBoard operations
        - Be helpful and provide clear responses about task operations
        - If a user wants to move a task, update its status (todo, doing, done)
        - When listing tasks, organize them by status if helpful
        - When creating tasks, ask for clarification if title or description is unclear
        
        {f'The user ID is: {user_id}. Always use this user ID when calling TaskBoard tools.' if user_id else 'User ID not available - tools may not work properly.'}
        
        Available task statuses: todo, doing, done
        
        Use natural language to explain what actions you're taking and their results.""",
        model="gpt-4o-mini",  # The LLM that powers the agent
        mcp_servers=[mcp_server]  # Your TaskBoard API tools
    )

@app.post("/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    # Generate session ID if not provided
    session_id = request.session_id or str(uuid.uuid4())
    
    # Count user messages in conversation history
    user_message_count = 1  # Current message
    for msg in request.conversation_history:
        if msg.get('role') == 'user':
            user_message_count += 1
    
    # Check if we've reached the limit (5 messages)
    if user_message_count > 5:
        return ChatResponse(
            response="This conversation has reached the maximum limit of 5 user messages. Please start a new conversation.",
            session_id=session_id,
            user_message_count=user_message_count
        )
    
    # Extract userId from conversation history
    user_id = extract_user_id_from_history(request.conversation_history)
    
    try:
        # Create MCP server connection
        mcp_server = await create_mcp_server()
        
        # Use the MCP server with timeout
        async with asyncio.timeout(180):  # 3 minute total timeout
            async with mcp_server as server:
                # Create agent with the connected MCP server
                agent = await create_agent_with_mcp(user_id, server)
                
                # Create session for conversation persistence
                session = SQLiteSession(session_id, "conversations.db")
                
                # Run the agent
                result = await Runner.run(
                    agent,
                    request.message,
                    session=session
                )
                
                # Extract tool usage information
                tool_usage = None
                if hasattr(result, 'tool_calls') and result.tool_calls:
                    tool_usage = {
                        "has_tools": True,
                        "tool_calls": [
                            {
                                "function": {
                                    "name": tc.get('name', 'unknown'),
                                    "arguments": tc.get('arguments', {})
                                },
                                "content": tc.get('result', 'No result')
                            } for tc in result.tool_calls
                        ]
                    }
                
                return ChatResponse(
                    response=result.final_output,
                    session_id=session_id,
                    user_message_count=user_message_count,
                    tool_usage=tool_usage
                )
                
    except asyncio.TimeoutError:
        return ChatResponse(
            response="The TaskBoard service is taking too long to respond. Please try again in a few minutes.",
            session_id=session_id,
            user_message_count=user_message_count
        )
    except Exception as e:
        print(f"Error in chat endpoint: {e}")
        return ChatResponse(
            response="I'm experiencing technical difficulties. Please try again in a moment.",
            session_id=session_id,
            user_message_count=user_message_count
        )

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "openai-agents-chat-microservice"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8085)
```

### How the agent works

The OpenAI Agents SDK handles the complexity:

1. **Agent receives tools**: When you connect it to the MCP server, it gets access to TaskBoard tools (like "get_items", "create_item", etc.)
2. **Agent plans actions**: When a user says "show overdue tasks", it decides which MCP tools to call
3. **Agent executes**: It calls the appropriate MCP tools, which in turn call your `/api/items` endpoint
4. **Agent formats response**: It takes the raw JSON response and turns it into natural language

You don't write any prompt engineering, tool calling logic, or response formatting. The SDK handles it all.

### Set up environment variables

Create environment configuration:

```bash
# mcp-agent-service/.env
OPENAI_API_KEY=your_openai_api_key_here
TASKBOARD_SERVER_URL=https://your-ngrok-url.ngrok.io  # Your ngrok URL from Step 1
```

## Step 4: Connect the frontend to the chat service

Finally we'll create the API route that connects your chat frontend to the chat service, ensuring user authentication is preserved.

### Add the chat API route

Create the chat API endpoint in your Next.js app:

```typescript
// taskboard/src/app/api/chat/route.ts
import { NextRequest, NextResponse } from 'next/server';

const CHAT_SERVICE_URL = process.env.CHAT_SERVICE_URL || 'http://localhost:8085';

export async function POST(request: NextRequest) {
  // Get userId from URL parameter (handled by middleware)
  let userId = request.headers.get('x-user-id');
  
  if (!userId) {
    userId = new URL(request.url).searchParams.get('userId');
  }

  if (!userId) {
    return NextResponse.json({ message: 'Unauthorized - userId required' }, { status: 401 });
  }

  try {
    const body = await request.json();

    // Prepare conversation history with user context
    const conversationHistory = body.conversation_history || [];
    
    // Add system message with user ID for security
    conversationHistory.unshift({
      role: 'system',
      content: `User ID: ${userId}. Always use this user ID when calling TaskBoard tools to ensure you access the correct user's data.`,
      timestamp: new Date().toISOString()
    });

    const requestBody = {
      message: body.message,
      conversation_history: conversationHistory,
      session_id: body.session_id,
    };
    
    // Forward to chat service
    const chatResponse = await fetch(`${CHAT_SERVICE_URL}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!chatResponse.ok) {
      throw new Error(`Chat service responded with status: ${chatResponse.status}`);
    }

    const chatData = await chatResponse.json();
    return NextResponse.json(chatData);
    
  } catch (error) {
    console.error('Chat API error:', error);
    return NextResponse.json(
      { message: 'Failed to process chat request' },
      { status: 500 }
    );
  }
}
```

### Update your middleware

Make sure your middleware includes the new chat route:

```typescript
// taskboard/src/middleware.ts
// Update the config at the bottom of the file:
export const config = {
  matcher: ['/api/items', '/api/items/:path*', '/api/chat'], // Add /api/chat
};
```

## Docker setup

Now we'll set up Docker to run both services together. This is the recommended way to test the complete chat-enabled application.

Create the Dockerfile for the chat service:

```dockerfile
# mcp-agent-service/Dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .

EXPOSE 8085
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8085"]
```

Update your docker-compose.yml to include both services:

```yaml
# docker-compose.yml
version: '3.8'

services:
  taskboard:
    build: ./taskboard
    ports:
      - "3000:3000"
    environment:
      - CHAT_SERVICE_URL=http://chat-service:8085
      - DATABASE_URL=${DATABASE_URL:-file:./prisma/dev.db}
    depends_on:
      - chat-service
    volumes:
      - ./taskboard/prisma/dev.db:/app/prisma/dev.db
    networks:
      - taskboard-network
    env_file:
      - .env

  chat-service:
    build: ./mcp-agent-service
    ports:
      - "8085:8085"
    environment:
      - PYTHONUNBUFFERED=1
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - TASKBOARD_SERVER_URL=${TASKBOARD_SERVER_URL:-http://taskboard:3000}
    networks:
      - taskboard-network
    env_file:
      - .env

networks:
  taskboard-network:
    driver: bridge
```

Make sure your `.env` file includes the required variables:

```bash
# .env
OPENAI_API_KEY=your_openai_api_key_here
TASKBOARD_SERVER_URL=https://your-ngrok-url.ngrok.io  # Your ngrok URL from Step 1
```

Start both services:

```bash
docker-compose up --build
```

### Test the complete integration

Visit `http://localhost:3000`, log in, and click the chat button. Try these test queries:

- "Show me all my tasks"
- "Create a task called 'Test the chat feature'"
- "Move the chat feature task to doing"

You should see:
1. **Chat responses** appear in the chat window
2. **Task board updates** automatically when AI performs actions
3. **Only your tasks** are visible/editable (user permissions respected)



<video width="600" controls>
  <source src="/videos/taskboard-new-task.mp4" type="video/mp4" />
    Your browser does not support the video tag.
</video>



## Troubleshooting

### Chat not responding
- Check that both services are running (`localhost:3000` and `localhost:8085`)
- Verify your OpenAI API key is valid
- Look for errors in both terminal windows

### AI can't access your tasks
- Confirm ngrok is running and you've updated the `TASKBOARD_SERVER_URL` in Gram
- Test your MCP server in the Gram Playground first
- Check that the user is properly authenticated in TaskBoard

### Permission errors
- Make sure the `userId` is being passed correctly through the chat flow
- Verify your API middleware is working: `curl "http://localhost:3000/api/items?userId=test"`

![Chat service logs displayed in the terminal](/img/blog/adding-ai-chat-to-your-app-guide/chat-service-logging.png)
